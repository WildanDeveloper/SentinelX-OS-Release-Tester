#!/bin/bash
#
# SentinelX OS — Testing Framework (sx-test)
# Copyright (C) 2026 WildanDev
# License: GPL v3
#
# Automated testing suite for kernel, packages, security, and installer.
#
set -euo pipefail

# ─────────────────────────────────────────────
#  CONSTANTS
# ─────────────────────────────────────────────
readonly VERSION="1.0.0"
readonly TEST_LOG="/tmp/sx-test-$(date +%Y%m%d-%H%M%S).log"
readonly TEST_RESULTS_DIR="test-results"

# Test counters
TESTS_TOTAL=0
TESTS_PASSED=0
TESTS_FAILED=0
TESTS_SKIPPED=0

# ─────────────────────────────────────────────
#  COLORS
# ─────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# ─────────────────────────────────────────────
#  LOGGING
# ─────────────────────────────────────────────
mkdir -p "$(dirname "$TEST_LOG")"
mkdir -p "$TEST_RESULTS_DIR"

exec > >(tee -a "$TEST_LOG") 2>&1

log_info()    { echo -e "${GREEN}[✓]${NC} $1"; }
log_warn()    { echo -e "${YELLOW}[!]${NC} $1"; }
log_error()   { echo -e "${RED}[✗]${NC} $1"; }
log_test()    { echo -e "${CYAN}[TEST]${NC} $1"; }
log_pass()    { echo -e "${GREEN}[PASS]${NC} $1"; ((TESTS_PASSED++)); }
log_fail()    { echo -e "${RED}[FAIL]${NC} $1"; ((TESTS_FAILED++)); }
log_skip()    { echo -e "${YELLOW}[SKIP]${NC} $1"; ((TESTS_SKIPPED++)); }
log_section() { echo -e "\n${BOLD}${MAGENTA}═══ $1 ═══${NC}\n"; }

# ─────────────────────────────────────────────
#  BANNER
# ─────────────────────────────────────────────
show_banner() {
    clear
    echo -e "${CYAN}${BOLD}"
    echo "╔══════════════════════════════════════════════╗"
    echo "║     SentinelX OS Testing Framework v${VERSION}    ║"
    echo "║         Automated Quality Assurance          ║"
    echo "╚══════════════════════════════════════════════╝"
    echo -e "${NC}"
    echo -e "  ${DIM}Log file: $TEST_LOG${NC}"
    echo ""
}

# ─────────────────────────────────────────────
#  TEST RUNNER
# ─────────────────────────────────────────────
run_test() {
    local name="$1"
    local command="$2"
    
    ((TESTS_TOTAL++))
    log_test "$name"
    
    if eval "$command" &>/dev/null; then
        log_pass "$name"
        return 0
    else
        log_fail "$name"
        return 1
    fi
}

run_test_with_output() {
    local name="$1"
    local command="$2"
    
    ((TESTS_TOTAL++))
    log_test "$name"
    
    local output
    if output=$(eval "$command" 2>&1); then
        log_pass "$name"
        echo "$output" | sed 's/^/    /'
        return 0
    else
        log_fail "$name"
        echo "$output" | sed 's/^/    /'
        return 1
    fi
}

# ─────────────────────────────────────────────
#  ENVIRONMENT CHECKS
# ─────────────────────────────────────────────
test_environment() {
    log_section "Environment Checks"
    
    run_test "Shell is Bash" "[ -n \"\$BASH_VERSION\" ]"
    run_test "Running on Linux" "[ \"\$(uname -s)\" == \"Linux\" ]"
    run_test "x86_64 architecture" "[ \"\$(uname -m)\" == \"x86_64\" ]"
    run_test "Root or sudo available" "command -v sudo &>/dev/null || [ \$EUID -eq 0 ]"
}

# ─────────────────────────────────────────────
#  KERNEL TESTS
# ─────────────────────────────────────────────
test_kernel() {
    log_section "Kernel Tests"
    
    # Check if kernel directory exists
    if [ ! -d "kernel" ]; then
        log_skip "Kernel directory not found"
        return 1
    fi
    
    # Test build script
    run_test "Kernel build script exists" "[ -f kernel/build.sh ]"
    run_test "Build script is executable" "[ -x kernel/build.sh ]"
    run_test "Kernel config file exists" "[ -f kernel/configs/sx-kernel.config ]"
    
    # Test patches
    if [ -d "kernel/patches" ]; then
        local patch_count
        patch_count=$(find kernel/patches -name "*.patch" | wc -l)
        run_test "Kernel patches present ($patch_count found)" "[ $patch_count -gt 0 ]"
        
        # Validate patch syntax
        for patch in kernel/patches/*.patch; do
            if [ -f "$patch" ]; then
                run_test "Patch $(basename "$patch") has valid format" \
                    "head -n 1 \"$patch\" | grep -qE '^(---|diff|From|Index)'"
            fi
        done
    fi
    
    # Test kernel version detection
    run_test_with_output "Detect kernel version in build script" \
        "grep -o 'KERNEL_VERSION=\"[^\"]*\"' kernel/build.sh"
}

# ─────────────────────────────────────────────
#  PACKAGE MANAGER TESTS
# ─────────────────────────────────────────────
test_packages() {
    log_section "Package Manager Tests"
    
    if [ ! -d "packages" ]; then
        log_skip "Packages directory not found"
        return 1
    fi
    
    # Test sx-pkg
    run_test "sx-pkg exists" "[ -f packages/sx-pkg ]"
    run_test "sx-pkg is executable" "[ -x packages/sx-pkg ]"
    run_test "sx-pkg config exists" "[ -f packages/sx-pkg.conf ]"
    
    # Test sx-pkg syntax
    run_test "sx-pkg has valid bash syntax" "bash -n packages/sx-pkg"
    
    # Test commands are defined
    local commands=("install" "remove" "update" "search" "info" "list")
    for cmd in "${commands[@]}"; do
        run_test "sx-pkg has '$cmd' command" \
            "grep -q \"^[[:space:]]*$cmd)\" packages/sx-pkg"
    done
    
    # Test package repository configs
    run_test "Pacman config exists" "[ -f packages/sx-pacman/config ] || [ ! -d packages/sx-pacman ]"
    run_test "RPM config exists" "[ -f packages/sx-rpm/config ] || [ ! -d packages/sx-rpm ]"
}

# ─────────────────────────────────────────────
#  SECURITY TESTS
# ─────────────────────────────────────────────
test_security() {
    log_section "Security Tests"
    
    if [ ! -d "security" ]; then
        log_skip "Security directory not found"
        return 1
    fi
    
    # AppArmor profiles
    if [ -d "security/apparmor" ]; then
        local profile_count
        profile_count=$(find security/apparmor -type f ! -name ".*" | wc -l)
        run_test "AppArmor profiles present ($profile_count found)" "[ $profile_count -gt 0 ]"
        
        # Test profile syntax (basic check)
        for profile in security/apparmor/*; do
            if [ -f "$profile" ] && [ "$(basename "$profile")" != ".gitkeep" ]; then
                run_test "AppArmor profile $(basename "$profile") is readable" "[ -r \"$profile\" ]"
            fi
        done
    fi
    
    # SELinux policies
    if [ -d "security/selinux" ]; then
        run_test "SELinux policy files exist" \
            "[ -f security/selinux/sentinelx.te ] || [ -f security/selinux/sentinelx.fc ]"
    fi
    
    # Hardening scripts
    if [ -d "security/hardening" ]; then
        run_test "Hardening script exists" "[ -f security/hardening/sx-harden ]"
        if [ -f "security/hardening/sx-harden" ]; then
            run_test "Hardening script has valid syntax" "bash -n security/hardening/sx-harden"
        fi
    fi
}

# ─────────────────────────────────────────────
#  INSTALLER TESTS
# ─────────────────────────────────────────────
test_installer() {
    log_section "Installer Tests"
    
    if [ ! -d "installer" ]; then
        log_skip "Installer directory not found"
        return 1
    fi
    
    # Test installer script
    run_test "Installer script exists" "[ -f installer/sx-install ]"
    run_test "Installer is executable" "[ -x installer/sx-install ]"
    run_test "Installer has valid bash syntax" "bash -n installer/sx-install"
    
    # Test installer documentation
    run_test "Installer README exists" "[ -f installer/README.md ]"
    
    # Test critical functions exist
    local functions=("partition_disk" "format_partitions" "install_base" "install_bootloader")
    for func in "${functions[@]}"; do
        run_test "Installer has '$func' function" \
            "grep -q \"^${func}()\" installer/sx-install"
    done
    
    # Test error handling
    run_test "Installer has error trap" \
        "grep -q \"trap.*ERR\" installer/sx-install"
}

# ─────────────────────────────────────────────
#  ISO BUILDER TESTS
# ─────────────────────────────────────────────
test_iso() {
    log_section "ISO Builder Tests"
    
    if [ ! -d "iso" ]; then
        log_skip "ISO directory not found"
        return 1
    fi
    
    # Test build script
    run_test "ISO build script exists" "[ -f iso/build-iso.sh ]"
    run_test "ISO script is executable" "[ -x iso/build-iso.sh ]"
    run_test "ISO script has valid syntax" "bash -n iso/build-iso.sh"
    
    # Test config
    run_test "ISO config exists" "[ -f iso/configs/iso.conf ]"
}

# ─────────────────────────────────────────────
#  DOCUMENTATION TESTS
# ─────────────────────────────────────────────
test_documentation() {
    log_section "Documentation Tests"
    
    # Core documentation
    run_test "Main README exists" "[ -f README.md ]"
    run_test "LICENSE file exists" "[ -f LICENSE ]"
    run_test "CONTRIBUTING guide exists" "[ -f CONTRIBUTING.md ]"
    run_test "ROADMAP exists" "[ -f ROADMAP.md ]"
    
    # Component documentation
    local components=("kernel" "packages" "security" "installer" "iso")
    for comp in "${components[@]}"; do
        if [ -d "$comp" ]; then
            run_test "$comp has README" "[ -f $comp/README.md ]"
        fi
    done
}

# ─────────────────────────────────────────────
#  CODE QUALITY TESTS
# ─────────────────────────────────────────────
test_code_quality() {
    log_section "Code Quality Tests"
    
    # Find all bash scripts
    local scripts
    mapfile -t scripts < <(find . -type f -name "*.sh" -o -name "sx-*" | grep -v ".git")
    
    for script in "${scripts[@]}"; do
        # Skip non-executable scripts in some cases
        if [ -f "$script" ]; then
            run_test "$(basename "$script") has valid bash syntax" "bash -n \"$script\""
            
            # Check for dangerous patterns
            run_test "$(basename "$script") avoids 'rm -rf /'" \
                "! grep -q 'rm[[:space:]]*-rf[[:space:]]*/[^/]' \"$script\""
            
            # Check for set -e or set -euo pipefail
            run_test "$(basename "$script") uses error handling" \
                "grep -qE '^set -[euo]' \"$script\""
        fi
    done
    
    # Check for TODO/FIXME markers
    local todo_count
    todo_count=$(grep -r "TODO\|FIXME" --include="*.sh" --include="sx-*" . | wc -l || echo 0)
    log_info "Found $todo_count TODO/FIXME markers in codebase"
}

# ─────────────────────────────────────────────
#  INTEGRATION TESTS
# ─────────────────────────────────────────────
test_integration() {
    log_section "Integration Tests"
    
    # Test if components reference each other correctly
    if [ -f "installer/sx-install" ] && [ -f "packages/sx-pkg" ]; then
        run_test "Installer references sx-pkg" \
            "grep -q 'sx-pkg' installer/sx-install"
    fi
    
    if [ -f "iso/build-iso.sh" ] && [ -f "kernel/build.sh" ]; then
        run_test "ISO builder can find kernel build" \
            "grep -qE '(kernel.*build|../kernel)' iso/build-iso.sh || true"
    fi
}

# ─────────────────────────────────────────────
#  PERFORMANCE TESTS
# ─────────────────────────────────────────────
test_performance() {
    log_section "Performance Tests"
    
    # Test script execution speed
    if [ -f "packages/sx-pkg" ]; then
        log_test "sx-pkg help command performance"
        local start
        start=$(date +%s%N)
        bash packages/sx-pkg help &>/dev/null || true
        local end
        end=$(date +%s%N)
        local duration=$(( (end - start) / 1000000 ))
        
        if [ "$duration" -lt 1000 ]; then
            log_pass "sx-pkg help executes in ${duration}ms (< 1s)"
        else
            log_fail "sx-pkg help takes ${duration}ms (should be < 1s)"
        fi
    fi
}

# ─────────────────────────────────────────────
#  GENERATE REPORT
# ─────────────────────────────────────────────
generate_report() {
    local report_file="$TEST_RESULTS_DIR/report-$(date +%Y%m%d-%H%M%S).txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "       SentinelX OS Test Report"
        echo "       Generated: $(date '+%Y-%m-%d %H:%M:%S')"
        echo "═══════════════════════════════════════════════"
        echo ""
        echo "Tests Total:   $TESTS_TOTAL"
        echo "Tests Passed:  $TESTS_PASSED ($(( TESTS_PASSED * 100 / TESTS_TOTAL ))%)"
        echo "Tests Failed:  $TESTS_FAILED"
        echo "Tests Skipped: $TESTS_SKIPPED"
        echo ""
        
        if [ "$TESTS_FAILED" -eq 0 ]; then
            echo "Status: ✓ ALL TESTS PASSED"
        else
            echo "Status: ✗ SOME TESTS FAILED"
        fi
        
        echo ""
        echo "Full log: $TEST_LOG"
    } | tee "$report_file"
    
    echo -e "\n${CYAN}Report saved to: $report_file${NC}"
}

# ─────────────────────────────────────────────
#  SUMMARY
# ─────────────────────────────────────────────
show_summary() {
    echo ""
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════${NC}"
    echo -e "${BOLD}              Test Summary${NC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════${NC}"
    echo ""
    
    printf "%-20s %s\n" "Total Tests:" "$TESTS_TOTAL"
    printf "%-20s ${GREEN}%s${NC}\n" "Passed:" "$TESTS_PASSED"
    printf "%-20s ${RED}%s${NC}\n" "Failed:" "$TESTS_FAILED"
    printf "%-20s ${YELLOW}%s${NC}\n" "Skipped:" "$TESTS_SKIPPED"
    
    echo ""
    
    if [ "$TESTS_FAILED" -eq 0 ]; then
        echo -e "${GREEN}${BOLD}✓ ALL TESTS PASSED!${NC}"
        echo -e "${GREEN}SentinelX OS is ready for deployment.${NC}"
    else
        echo -e "${RED}${BOLD}✗ SOME TESTS FAILED${NC}"
        echo -e "${RED}Please review the log and fix issues: $TEST_LOG${NC}"
    fi
    
    echo ""
}

# ─────────────────────────────────────────────
#  USAGE
# ─────────────────────────────────────────────
show_usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --all          Run all tests (default)"
    echo "  --kernel       Test kernel build system only"
    echo "  --packages     Test package manager only"
    echo "  --security     Test security configurations only"
    echo "  --installer    Test installer only"
    echo "  --iso          Test ISO builder only"
    echo "  --docs         Test documentation only"
    echo "  --quality      Test code quality only"
    echo "  --fast         Skip slow tests"
    echo "  --help         Show this help"
    echo ""
}

# ─────────────────────────────────────────────
#  MAIN
# ─────────────────────────────────────────────
main() {
    show_banner
    
    local mode="${1:-all}"
    
    case "$mode" in
        --help|-h)
            show_usage
            exit 0
            ;;
        --kernel)
            test_environment
            test_kernel
            ;;
        --packages)
            test_environment
            test_packages
            ;;
        --security)
            test_environment
            test_security
            ;;
        --installer)
            test_environment
            test_installer
            ;;
        --iso)
            test_environment
            test_iso
            ;;
        --docs)
            test_documentation
            ;;
        --quality)
            test_code_quality
            ;;
        --fast)
            test_environment
            test_kernel
            test_packages
            test_installer
            ;;
        --all|*)
            test_environment
            test_kernel
            test_packages
            test_security
            test_installer
            test_iso
            test_documentation
            test_code_quality
            test_integration
            test_performance
            ;;
    esac
    
    # Generate report and show summary
    generate_report
    show_summary
    
    # Exit with proper code
    [ "$TESTS_FAILED" -eq 0 ] && exit 0 || exit 1
}

main "$@"
